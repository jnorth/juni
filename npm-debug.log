0 info it worked if it ends with ok
1 verbose cli [ 'node', '/usr/local/bin/npm', 'publish' ]
2 info using npm@1.4.28
3 info using node@v0.10.35
4 verbose publish [ '.' ]
5 verbose cache add [ '.', null ]
6 verbose cache add name=undefined spec="." args=[".",null]
7 verbose parsed url { protocol: null,
7 verbose parsed url   slashes: null,
7 verbose parsed url   auth: null,
7 verbose parsed url   host: null,
7 verbose parsed url   port: null,
7 verbose parsed url   hostname: null,
7 verbose parsed url   hash: null,
7 verbose parsed url   search: null,
7 verbose parsed url   query: null,
7 verbose parsed url   pathname: '.',
7 verbose parsed url   path: '.',
7 verbose parsed url   href: '.' }
8 silly lockFile 3a52ce78- .
9 verbose lock . /Users/pxu/.npm/3a52ce78-.lock
10 verbose tar pack [ '/Users/pxu/.npm/juni/0.1.0/package.tgz', '.' ]
11 verbose tarball /Users/pxu/.npm/juni/0.1.0/package.tgz
12 verbose folder .
13 info prepublish juni@0.1.0
14 silly lockFile 1f1177db-tar tar://.
15 verbose lock tar://. /Users/pxu/.npm/1f1177db-tar.lock
16 silly lockFile c0247f3d-s-pxu-npm-juni-0-1-0-package-tgz tar:///Users/pxu/.npm/juni/0.1.0/package.tgz
17 verbose lock tar:///Users/pxu/.npm/juni/0.1.0/package.tgz /Users/pxu/.npm/c0247f3d-s-pxu-npm-juni-0-1-0-package-tgz.lock
18 silly lockFile 1f1177db-tar tar://.
19 silly lockFile 1f1177db-tar tar://.
20 silly lockFile c0247f3d-s-pxu-npm-juni-0-1-0-package-tgz tar:///Users/pxu/.npm/juni/0.1.0/package.tgz
21 silly lockFile c0247f3d-s-pxu-npm-juni-0-1-0-package-tgz tar:///Users/pxu/.npm/juni/0.1.0/package.tgz
22 silly lockFile f7163556-Users-pxu-npm-juni-0-1-0-package /Users/pxu/.npm/juni/0.1.0/package
23 verbose lock /Users/pxu/.npm/juni/0.1.0/package /Users/pxu/.npm/f7163556-Users-pxu-npm-juni-0-1-0-package.lock
24 silly lockFile f7163556-Users-pxu-npm-juni-0-1-0-package /Users/pxu/.npm/juni/0.1.0/package
25 silly lockFile f7163556-Users-pxu-npm-juni-0-1-0-package /Users/pxu/.npm/juni/0.1.0/package
26 silly lockFile 3a52ce78- .
27 silly lockFile 3a52ce78- .
28 silly publish { name: 'juni',
28 silly publish   version: '0.1.0',
28 silly publish   description: 'A tree-based build system.',
28 silly publish   main: 'index.js',
28 silly publish   author: { name: 'Joseph North' },
28 silly publish   license: 'MIT',
28 silly publish   keywords: [ 'juni' ],
28 silly publish   repository: { type: 'git', url: 'git://github.com/jnorth/juni' },
28 silly publish   readme: '# Juni\n\n**A tree-based build system.**\n\nJuni is a simple build system that acts on file system trees. Plugins are then\napplied to the tree, and manipulate it in-place.\n\n## Example Usage\n\nJuni does not come with a CLI tool, or require you to have a special `*file.js`\nin your project folder. Just write your own build script and run it how you\nlike.\n\n```javascript\nvar juni = require("juni");\n\nnew juni.Tree("./source")\n  .pipe(juni.populate())\n  // Call more plugins ...\n  .pipe(juni.output("./build"));\n```\n\n## Trees\n\nJuni is based around the `Tree` class. A `Tree` instance represents either a\nfile or folder on the file system. Typically a plugin will take a tree and\nmodify, remove, or add children to it.\n\n##### `Tree.path()`\n\nGet the path to the tree. This is typically the value that was set in the\nconstructor, though plugins can change it.\n\n##### `Tree.setPath(path)`\n\nSet the path to the tree on the file system.\n\n##### `Tree.isDirectory()`\n\nReturns true if the tree is a directory.\n\n##### `Tree.isFile()`\n\nReturns true if the tree is a file.\n\n##### `Tree.hasParent()`\n\nReturns true if the tree has a parent tree. Will be false for the root tree.\n\n##### `Tree.parent()`\n\nReturns the parent tree, or `null` if it has none.\n\n##### `Tree.hasChildren()`\n\nReturns true if the tree has child trees. Will be false for files and empty\ndirectories.\n\n##### `Tree.children()`\n\nReturns an array of child trees.\n\n##### `Tree.contents()`\n\nReturns a tree\'s file contents as a buffer. Only makes sense for file trees.\n\n##### `Tree.setContents(contents)`\n\nSet a tree\'s file contents. `contents` should be a buffer or a string. Strings\nwill be automatically converted to a buffer.\n\n##### `Tree.remove()`\n\nRemoves a tree from its parent tree.\n\n##### `Tree.addChild()`\n\nAdds a child tree to a tree.\n\n##### `Tree.walk(walker)`\n\nTraverses the tree using a walker. See "Walking" below.\n\n##### `Tree.match(matcher)`\n\nReturns true if the tree matches the matcher. See "Matching" below.\n\n##### `Tree.pipe(transform)`\n\nPass the tree through a transform function. Transform functions are typically\nreturned by plugins. See "Plugins" below.\n\n## Walking\n\nIn a tree-based build system, being able to traverse trees easily and in custom\nways is super important. The `Tree.walk` method traverses a tree using `walkers`.\n\nWalkers are just functions. They accept a tree and a function, and call the\nfunction with each tree node it visits. Which nodes it visits, and in what order\nare up the the walker.\n\nWalkers can also return a value, making them a powerful way to extract nodes\nfrom the tree or compute values based on the tree.\n\nIf that sounds complicated, don\'t worry. You really only need to use walkers\nwhen building plugins, and even then you can probably just use the walkers\nbundled along with Juni.\n\n### Bundled Walkers\n\n#### `juni.walk.pre`\n\nVisit each item in the tree with a pre-order traversal.\n\nThis traversal ensures that all parent nodes will be visited before their\nchildren. Useful for copying the tree, for example to the file system.\n\nExample usage:\n\n```javascript\nvar juni = require("juni");\n\nvar tree = new juni.tree("/my/path")\n  .pipe(populate());\n\ntree.walk(juni.walk.pre(function(item)){\n  console.log(item.path());\n});\n```\n\nA folder stucture like:\n\n```\n/my/path/scripts\n/my/path/scripts/app.coffee\n/my/path/scripts/main.js\n/my/path/scripts/vendor\n/my/path/scripts/vendor/jquery.js\n```\n\nwill output:\n\n```\n/my/path/scripts\n/my/path/scripts/app.coffee\n/my/path/scripts/main.js\n/my/path/scripts/vendor\n/my/path/scripts/vendor/jquery.js\n```\n\n#### `juni.walk.post`\n\nVisit each item in the tree with a post-order traversal.\n\nThis traversal ensures that all children nodes will be visited before their\nparents. Useful when removing nodes from the tree.\n\nExample usage:\n\n```javascript\nvar juni = require("juni");\n\nvar tree = new juni.tree("/my/path")\n  .pipe(populate());\n\ntree.walk(juni.walk.post(function(item)){\n  console.log(item.path());\n});\n```\n\nA folder stucture like:\n\n```\n/my/path/scripts\n/my/path/scripts/app.coffee\n/my/path/scripts/main.js\n/my/path/scripts/vendor\n/my/path/scripts/vendor/jquery.js\n```\n\nwill output:\n\n```\n/my/path/scripts/vendor/jquery.js\n/my/path/scripts/vendor\n/my/path/scripts/main.js\n/my/path/scripts/app.coffee\n/my/path/scripts\n```\n\n## Matching\n\nMatchers can be used to see if a tree node matches some specific queries. For\nexample you can check if the filename contains "foo", or see if the modified\ndate is over a day ago.\n\nThe `Tree.match` method uses `matchers` to decide if it returns true or false.\nSimilar to walkers, matchers are just functions. They accept a tree and return\ntrue or false.\n\n### Bundled Matchers\n\nThe matchers that come bundled with Juni all accept a `query`, which is a\nstring, regex, function, or an array of those. Strings and regular expressions\nare used to match against the tree filename.\n\nIf you want to match against something else, you can pass in your own function.\nA tree node is passed in and you can return true or false based on that.\n\n#### `juni.match.any`\n\nReturns true if any query matches the tree node.\n\n```javascript\nvar match = tree.match(juni.match.any(["foo", /^_/]));\n\n// tree.path() == "foolhardy" => true\n// tree.path() == "_sadpanda" => true\n// tree.path() == "banana stand" => false\n```\n\n#### `juni.match.all`\n\nReturns true if all queries match the tree node.\n\n```javascript\nvar match = tree.match(juni.match.all(["foo", /^_/]));\n\n// tree.path() == "foolhardy" => false\n// tree.path() == "_sadpanda" => false\n// tree.path() == "banana stand" => false\n// tree.path() == "_eatfood" => true\n```\n\n### Query Functions\n\nIf just matching against the filename isn\'t enough, you can pass a function to\nthe bundled matchers:\n\n```javascript\nvar inFooPathQuery = function(tree) {\n  return tree.path().indexOf("foo/") !== -1;\n};\n\ntree.match(juni.match.all(inFooPathQuery));\n```\n\n## Plugins\n\nJuni plugins are used with the `Tree.pipe` method.\n\n### Bundled Plugins\n\n#### `juni.populate`\n\nRecursively builds a tree containing file system items in the current tree\'s\npath. You basically always want to call this after creating a new tree.\n\n```javascript\nvar tree = new juni.Tree("/my/path");\ntree.hasChildren() // => false\n\ntree.pipe(juni.populate());\ntree.hasChildren() // => true\n```\n\n#### `juni.print`\n\nPrints a tree to the console. Useful for debugging.\n\n#### `juni.output(dest)`\n\nWrites the tree to the file system at the `dest` path.\n\n```javascript\n// Copy all files from source to build\nnew juni.Tree("./source")\n  .pipe(populate())\n  .pipe(output("./build"));\n```\n\n### Building a Plugin\n\nThe `Tree.pipe` method expects a function that accepts a `Tree` object. The\nreturn value doesn\'t matter. We call this a `transform` function.\n\nTypically a plugin might want to accept options or other input though, so by\nconvention, a Juni plugin is a function that accepts any arguments and returns a\ntransform function. An example makes this clearer:\n\n```javascript\n// Here is a simple transform function that will append some text to all files\n// in a juni tree.\nvar appender = function(tree) {\n  tree.walk(juni.walk.pre(function(item){\n    if (item.isFile()) {\n      var contents = item.contents().toString();\n      item.setContents(contents + "Appender was here!");\n    }\n  }));\n};\n\ntree.pipe(appender);\n\n// This would be much more useful if we could specifiy the text to append.\n// Let\'s make a simple plugin\nvar appender = function(appendString) {\n  // Return a transform function\n  return function(tree) {\n    tree.walk(juni.walk.pre(function(item){\n      if (item.isFile()) {\n        var contents = item.contents().toString();\n        item.setContents(contents + appendString);\n      }\n    }));\n  };\n};\n\n// Our appender plugin is now a plugin--it has to be called before it is passed\n// to `Tree.pipe`.\nvar dateAppender = appender(new Date());\ntree.pipe(dateAppender);\n\n// or simply\ntree.pipe(appender(new Date()));\n```\n',
28 silly publish   readmeFilename: 'README.md',
28 silly publish   gitHead: '2dd76b793b1649200c45101a019a9f52531a238a',
28 silly publish   bugs: { url: 'https://github.com/jnorth/juni/issues' },
28 silly publish   homepage: 'https://github.com/jnorth/juni',
28 silly publish   _id: 'juni@0.1.0',
28 silly publish   scripts: {},
28 silly publish   _shasum: 'fca61fc2946a4f3b2bce68486f9bfad6c8b236d6',
28 silly publish   _from: '.' }
29 verbose request where is /juni
30 verbose request registry https://registry.npmjs.org/
31 verbose request id 7e183035170d5735
32 verbose url raw /juni
33 verbose url resolving [ 'https://registry.npmjs.org/', './juni' ]
34 verbose url resolved https://registry.npmjs.org/juni
35 verbose request where is https://registry.npmjs.org/juni
36 info trying registry request attempt 1 at 17:19:24
37 http PUT https://registry.npmjs.org/juni
38 http 403 https://registry.npmjs.org/juni
39 verbose headers { date: 'Fri, 06 Feb 2015 01:19:25 GMT',
39 verbose headers   server: 'CouchDB/1.5.0 (Erlang OTP/R16B03)',
39 verbose headers   'content-type': 'application/json',
39 verbose headers   'cache-control': 'max-age=60',
39 verbose headers   'content-length': '11597',
39 verbose headers   'accept-ranges': 'bytes',
39 verbose headers   via: '1.1 varnish',
39 verbose headers   'x-served-by': 'cache-lax1426-LAX',
39 verbose headers   'x-cache': 'MISS',
39 verbose headers   'x-cache-hits': '0',
39 verbose headers   'x-timer': 'S1423185565.171995,VS0,VE148',
39 verbose headers   'keep-alive': 'timeout=10, max=50',
39 verbose headers   connection: 'Keep-Alive' }
40 error publish Failed PUT 403
41 error Error: forbidden cannot modify pre-existing version: 0.1.0
41 error old={"name":"juni","version":"0.1.0","description":"A tree-based build system.","main":"index.js","author":{"name":"Joseph North"},"license":"MIT","gitHead":"2846fdd4a6e0c7b026d38ba96fa71b969f358cb3","_id":"juni@0.1.0","scripts":{},"_shasum":"acc5c0b9a6823ea2a98de8dc4a48e2e3419be3cc","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"north","email":"north@sublink.ca"},"maintainers":[{"name":"north","email":"north@sublink.ca"}],"dist":{"shasum":"acc5c0b9a6823ea2a98de8dc4a48e2e3419be3cc","tarball":"http://registry.npmjs.org/juni/-/juni-0.1.0.tgz"}}
41 error new={"name":"juni","version":"0.1.0","description":"A tree-based build system.","main":"index.js","author":{"name":"Joseph North"},"license":"MIT","keywords":["juni"],"repository":{"type":"git","url":"git://github.com/jnorth/juni"},"readme":"# Juni\u000a\u000a**A tree-based build system.**\u000a\u000aJuni is a simple build system that acts on file system trees. Plugins are then\u000aapplied to the tree, and manipulate it in-place.\u000a\u000a## Example Usage\u000a\u000aJuni does not come with a CLI tool, or require you to have a special `*file.js`\u000ain your project folder. Just write your own build script and run it how you\u000alike.\u000a\u000a```javascript\u000avar juni = require(\"juni\");\u000a\u000anew juni.Tree(\"./source\")\u000a  .pipe(juni.populate())\u000a  // Call more plugins ...\u000a  .pipe(juni.output(\"./build\"));\u000a```\u000a\u000a## Trees\u000a\u000aJuni is based around the `Tree` class. A `Tree` instance represents either a\u000afile or folder on the file system. Typically a plugin will take a tree and\u000amodify, remove, or add children to it.\u000a\u000a##### `Tree.path()`\u000a\u000aGet the path to the tree. This is typically the value that was set in the\u000aconstructor, though plugins can change it.\u000a\u000a##### `Tree.setPath(path)`\u000a\u000aSet the path to the tree on the file system.\u000a\u000a##### `Tree.isDirectory()`\u000a\u000aReturns true if the tree is a directory.\u000a\u000a##### `Tree.isFile()`\u000a\u000aReturns true if the tree is a file.\u000a\u000a##### `Tree.hasParent()`\u000a\u000aReturns true if the tree has a parent tree. Will be false for the root tree.\u000a\u000a##### `Tree.parent()`\u000a\u000aReturns the parent tree, or `null` if it has none.\u000a\u000a##### `Tree.hasChildren()`\u000a\u000aReturns true if the tree has child trees. Will be false for files and empty\u000adirectories.\u000a\u000a##### `Tree.children()`\u000a\u000aReturns an array of child trees.\u000a\u000a##### `Tree.contents()`\u000a\u000aReturns a tree's file contents as a buffer. Only makes sense for file trees.\u000a\u000a##### `Tree.setContents(contents)`\u000a\u000aSet a tree's file contents. `contents` should be a buffer or a string. Strings\u000awill be automatically converted to a buffer.\u000a\u000a##### `Tree.remove()`\u000a\u000aRemoves a tree from its parent tree.\u000a\u000a##### `Tree.addChild()`\u000a\u000aAdds a child tree to a tree.\u000a\u000a##### `Tree.walk(walker)`\u000a\u000aTraverses the tree using a walker. See \"Walking\" below.\u000a\u000a##### `Tree.match(matcher)`\u000a\u000aReturns true if the tree matches the matcher. See \"Matching\" below.\u000a\u000a##### `Tree.pipe(transform)`\u000a\u000aPass the tree through a transform function. Transform functions are typically\u000areturned by plugins. See \"Plugins\" below.\u000a\u000a## Walking\u000a\u000aIn a tree-based build system, being able to traverse trees easily and in custom\u000aways is super important. The `Tree.walk` method traverses a tree using `walkers`.\u000a\u000aWalkers are just functions. They accept a tree and a function, and call the\u000afunction with each tree node it visits. Which nodes it visits, and in what order\u000aare up the the walker.\u000a\u000aWalkers can also return a value, making them a powerful way to extract nodes\u000afrom the tree or compute values based on the tree.\u000a\u000aIf that sounds complicated, don't worry. You really only need to use walkers\u000awhen building plugins, and even then you can probably just use the walkers\u000abundled along with Juni.\u000a\u000a### Bundled Walkers\u000a\u000a#### `juni.walk.pre`\u000a\u000aVisit each item in the tree with a pre-order traversal.\u000a\u000aThis traversal ensures that all parent nodes will be visited before their\u000achildren. Useful for copying the tree, for example to the file system.\u000a\u000aExample usage:\u000a\u000a```javascript\u000avar juni = require(\"juni\");\u000a\u000avar tree = new juni.tree(\"/my/path\")\u000a  .pipe(populate());\u000a\u000atree.walk(juni.walk.pre(function(item)){\u000a  console.log(item.path());\u000a});\u000a```\u000a\u000aA folder stucture like:\u000a\u000a```\u000a/my/path/scripts\u000a/my/path/scripts/app.coffee\u000a/my/path/scripts/main.js\u000a/my/path/scripts/vendor\u000a/my/path/scripts/vendor/jquery.js\u000a```\u000a\u000awill output:\u000a\u000a```\u000a/my/path/scripts\u000a/my/path/scripts/app.coffee\u000a/my/path/scripts/main.js\u000a/my/path/scripts/vendor\u000a/my/path/scripts/vendor/jquery.js\u000a```\u000a\u000a#### `juni.walk.post`\u000a\u000aVisit each item in the tree with a post-order traversal.\u000a\u000aThis traversal ensures that all children nodes will be visited before their\u000aparents. Useful when removing nodes from the tree.\u000a\u000aExample usage:\u000a\u000a```javascript\u000avar juni = require(\"juni\");\u000a\u000avar tree = new juni.tree(\"/my/path\")\u000a  .pipe(populate());\u000a\u000atree.walk(juni.walk.post(function(item)){\u000a  console.log(item.path());\u000a});\u000a```\u000a\u000aA folder stucture like:\u000a\u000a```\u000a/my/path/scripts\u000a/my/path/scripts/app.coffee\u000a/my/path/scripts/main.js\u000a/my/path/scripts/vendor\u000a/my/path/scripts/vendor/jquery.js\u000a```\u000a\u000awill output:\u000a\u000a```\u000a/my/path/scripts/vendor/jquery.js\u000a/my/path/scripts/vendor\u000a/my/path/scripts/main.js\u000a/my/path/scripts/app.coffee\u000a/my/path/scripts\u000a```\u000a\u000a## Matching\u000a\u000aMatchers can be used to see if a tree node matches some specific queries. For\u000aexample you can check if the filename contains \"foo\", or see if the modified\u000adate is over a day ago.\u000a\u000aThe `Tree.match` method uses `matchers` to decide if it returns true or false.\u000aSimilar to walkers, matchers are just functions. They accept a tree and return\u000atrue or false.\u000a\u000a### Bundled Matchers\u000a\u000aThe matchers that come bundled with Juni all accept a `query`, which is a\u000astring, regex, function, or an array of those. Strings and regular expressions\u000aare used to match against the tree filename.\u000a\u000aIf you want to match against something else, you can pass in your own function.\u000aA tree node is passed in and you can return true or false based on that.\u000a\u000a#### `juni.match.any`\u000a\u000aReturns true if any query matches the tree node.\u000a\u000a```javascript\u000avar match = tree.match(juni.match.any([\"foo\", /^_/]));\u000a\u000a// tree.path() == \"foolhardy\" => true\u000a// tree.path() == \"_sadpanda\" => true\u000a// tree.path() == \"banana stand\" => false\u000a```\u000a\u000a#### `juni.match.all`\u000a\u000aReturns true if all queries match the tree node.\u000a\u000a```javascript\u000avar match = tree.match(juni.match.all([\"foo\", /^_/]));\u000a\u000a// tree.path() == \"foolhardy\" => false\u000a// tree.path() == \"_sadpanda\" => false\u000a// tree.path() == \"banana stand\" => false\u000a// tree.path() == \"_eatfood\" => true\u000a```\u000a\u000a### Query Functions\u000a\u000aIf just matching against the filename isn't enough, you can pass a function to\u000athe bundled matchers:\u000a\u000a```javascript\u000avar inFooPathQuery = function(tree) {\u000a  return tree.path().indexOf(\"foo/\") !== -1;\u000a};\u000a\u000atree.match(juni.match.all(inFooPathQuery));\u000a```\u000a\u000a## Plugins\u000a\u000aJuni plugins are used with the `Tree.pipe` method.\u000a\u000a### Bundled Plugins\u000a\u000a#### `juni.populate`\u000a\u000aRecursively builds a tree containing file system items in the current tree's\u000apath. You basically always want to call this after creating a new tree.\u000a\u000a```javascript\u000avar tree = new juni.Tree(\"/my/path\");\u000atree.hasChildren() // => false\u000a\u000atree.pipe(juni.populate());\u000atree.hasChildren() // => true\u000a```\u000a\u000a#### `juni.print`\u000a\u000aPrints a tree to the console. Useful for debugging.\u000a\u000a#### `juni.output(dest)`\u000a\u000aWrites the tree to the file system at the `dest` path.\u000a\u000a```javascript\u000a// Copy all files from source to build\u000anew juni.Tree(\"./source\")\u000a  .pipe(populate())\u000a  .pipe(output(\"./build\"));\u000a```\u000a\u000a### Building a Plugin\u000a\u000aThe `Tree.pipe` method expects a function that accepts a `Tree` object. The\u000areturn value doesn't matter. We call this a `transform` function.\u000a\u000aTypically a plugin might want to accept options or other input though, so by\u000aconvention, a Juni plugin is a function that accepts any arguments and returns a\u000atransform function. An example makes this clearer:\u000a\u000a```javascript\u000a// Here is a simple transform function that will append some text to all files\u000a// in a juni tree.\u000avar appender = function(tree) {\u000a  tree.walk(juni.walk.pre(function(item){\u000a    if (item.isFile()) {\u000a      var contents = item.contents().toString();\u000a      item.setContents(contents + \"Appender was here!\");\u000a    }\u000a  }));\u000a};\u000a\u000atree.pipe(appender);\u000a\u000a// This would be much more useful if we could specifiy the text to append.\u000a// Let's make a simple plugin\u000avar appender = function(appendString) {\u000a  // Return a transform function\u000a  return function(tree) {\u000a    tree.walk(juni.walk.pre(function(item){\u000a      if (item.isFile()) {\u000a        var contents = item.contents().toString();\u000a        item.setContents(contents + appendString);\u000a      }\u000a    }));\u000a  };\u000a};\u000a\u000a// Our appender plugin is now a plugin--it has to be called before it is passed\u000a// to `Tree.pipe`.\u000avar dateAppender = appender(new Date());\u000atree.pipe(dateAppender);\u000a\u000a// or simply\u000atree.pipe(appender(new Date()));\u000a```\u000a","readmeFilename":"README.md","gitHead":"2dd76b793b1649200c45101a019a9f52531a238a","bugs":{"url":"https://github.com/jnorth/juni/issues"},"homepage":"https://github.com/jnorth/juni","_id":"juni@0.1.0","scripts":{},"_shasum":"fca61fc2946a4f3b2bce68486f9bfad6c8b236d6","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"north","email":"north@sublink.ca"},"maintainers":[{"name":"north","email":"north@sublink.ca"}],"dist":{"shasum":"fca61fc2946a4f3b2bce68486f9bfad6c8b236d6","tarball":"http://registry.npmjs.org/juni/-/juni-0.1.0.tgz"}}: juni
41 error     at RegClient.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:308:14)
41 error     at Request._callback (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:246:65)
41 error     at Request.self.callback (/usr/local/lib/node_modules/npm/node_modules/request/request.js:236:22)
41 error     at Request.emit (events.js:98:17)
41 error     at Request.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:1142:14)
41 error     at Request.emit (events.js:117:20)
41 error     at IncomingMessage.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:1096:12)
41 error     at IncomingMessage.emit (events.js:117:20)
41 error     at _stream_readable.js:944:16
41 error     at process._tickCallback (node.js:442:13)
42 error If you need help, you may report this *entire* log,
42 error including the npm and node versions, at:
42 error     <http://github.com/npm/npm/issues>
43 error System Darwin 14.0.0
44 error command "node" "/usr/local/bin/npm" "publish"
45 error cwd /Users/pxu/Development/tools/juni/juni
46 error node -v v0.10.35
47 error npm -v 1.4.28
48 verbose exit [ 1, true ]
